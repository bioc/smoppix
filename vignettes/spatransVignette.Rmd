---
title: "Vignette of the spatrans package"
author: Stijn Hawinkel
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Vignette of the oosse package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This vignette demonstrates the use of the __spatrans__ package for statistical inference on single-molecule spatial transcriptomics datasets with replication.

\setcounter{tocdepth}{5}
\tableofcontents

# Installation instructions

The package can be installed from Bioconductor as follows:

```{r install, eval = FALSE}
library(Biocmanager)
install("spatrans")
```

Alternatively, the latest version can be downloaded from github as:

```{r installAndLoadGitHub, eval = FALSE}
library(devtools)
install_github("CenterForStatistics-UGent/spatrans")
```

```{r load}
library(spatrans)
```

# Yang data: lycophyte roots

As example dataset we use the data by \textcite{Yang2023} on _Selaginella moellendorffii_. Only a subset of the data, consisting of sections 1-3 of roots 1-3 is included for computational reasons. The data is loaded as follows.

```{r}
data(Yang)
head(Yang)
```

It is a dataframe containing molecule locations (x- and y-variables), gene identity and covariates: day, root and section. At each day, 6 roots were measured, with varying numbers of sections for each root. The analysis will need to account for this nested design.

The first step in the analysis is to build a hyperframe as provided in the _spatstat_ package, which consists of all different point patterns and their covariates

```{r}
hypYang = buildHyperFrame(Yang, coordVars = c("x", "y"), designVar = c("day", "root", "section"))
```

As printed by the code, `r nrow(hypYang)` design factors or point patterns were found. We take a closer look at the hyperframe

```{r}
hypYang
```

We see the following elements:

 - __ppp__: the _spatstat_ point patterns of class _ppp_
 - __design__: The design variable uniquely defining each point pattern. Is a concatenation of the day, root and section variables.
 - __day__, __root__ and __section__: the covariates
 - __tabObs__: tabulation of the frequency of each gene in each point pattern
 
 Zooming in on the first point pattern:
 
```{r}
hypYang$ppp[[1]]
```

As a final confirmation of successfully reading in the data, we can make an exploratory plot:

```{r}
plotExplore(hypYang)
```

# Analyses

## Multithreading

The _spatrans_ package can be computationally intensive, especially for gene pairs. For this reason we provide multithreading through the _BiocParallel_ package. All the user needs to do is prepare the parallel backend as follows:

```{r}
library(BiocParallel)
nCores = 2 #The number of CPUs
register(MulticoreParam(nCores))
```

## Univariate tests

### Tests for univariate aggregation or regularity: interevent distances

The first round of tests concerns the aggregation or regularity of individual genes. We choose to work with nearest neighbour distances here. The background of all other genes serves as null distribution, i.e. we look for genes aggregated _with respect to_ all other genes

```{r}
nnObj = estPims(hypYang, pis = "nn", null = "background")
```

A data-driven weighing function is now fitted to the estimates of all genes to share information on variances across features. This requires information on the design too.

```{r}
wfNN = buildWeightFunction(nnObj, pi = "nn", hypFrame = hypYang, designVars = c("day", "root"))
```

The fitted trend can be plotted:

```{r}
plotWf(wfNN)
```

As expected the weight increases with the number of observations. Using this relation between number of observations and variance, a linear mixed model can be fitted per feature. A built-in function prepares the dataframe for a specified gene (here _SmAHK4e_):

```{r}
dfUniNN = buildDfMM(nnObj, gene = "SmAHK4e", pi  = "nn", hypFrame = hypYang, weightFunction = wfNN, designVars = c("day", "root"))
```

This dataframe can then be used for mixed modelling, either in R or in an other software package. We present an example analysis below using the _lmerTest_ package, which enhances the _lmer_ package by providing p-values. We fit the following linear mixed model (LMM). The day variable enters the model as a fixed effect, the root as a random effect. We use sum coding for the day variable, meaning that two dummies are created, one for "day0" and one for "day3", so without a reference level. Instead the corresponding parameters are constrained to sum to zero, i.e. to be each other's opposite in this case. This maintains the interpretability of the intercept as the baseline pi, from which the different days can depart, and allows meaningful inference on the intercept.

```{r}
library(lmerTest)
lmeMod = lmer(pi - 0.5 ~ day + (1|root), data = dfUniNN, na.action = na.omit, 
                                 weights = weight, contrasts = list("day" = "contr.sum"))
```

Alternatively, a wrapper function is available that fits such LMMs for every gene:

```{r}
allModsNN = fitLMMs(nnObj, pi  = "nn", hypFrame = hypYang, weightFunction = wfNN, 
                    fixedVars = "day", randomVars = "root")
```


## Bivariate tests

### Tests for colocalization or antilocalization: interfeature distances

```{r}
nnPairObj = estPims(hypYang, pis = "nnPair", null = "background", 
                    features = attr(hypYang, "features")[seq_len(20)])
#Limit to 20 features for computational reasons
wfNNpair = buildWeightFunction(nnPairObj, pi = "nnPair", hypFrame = hypYang, designVars = c("day", "root"))
plotWf(wfNNpair)
```

# Eng2019: Mouse brain cells

### Tests for vicinity to cell wall or fixed point: distances to fixed objects
 
# Session info

```{r}
sessionInfo()
```


