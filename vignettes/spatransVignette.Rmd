---
title: "Vignette of the spatrans package"
author: Stijn Hawinkel
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Vignette of the oosse package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This vignette demonstrates the use of the __spatrans__ package for statistical inference on single-molecule spatial transcriptomics datasets with replication.

\setcounter{tocdepth}{5}
\tableofcontents

# Installation instructions

The package can be installed from Bioconductor as follows:

```{r install, eval = FALSE}
library(Biocmanager)
install("spatrans")
```

Alternatively, the latest version can be downloaded from github as:

```{r installAndLoadGitHub, eval = FALSE}
library(devtools)
install_github("CenterForStatistics-UGent/spatrans")
```

```{r load}
library(spatrans)
```

# Yang data: lycophyte roots

As example dataset we use the data by \textcite{Yang2023} on _Selaginella moellendorffii_. Only a subset of the data, consisting of sections 1-3 of roots 1-3 is included for computational reasons. The data is loaded as follows.

```{r}
data(Yang)
head(Yang)
```

It is a dataframe containing molecule locations (x- and y-variables), gene identity and covariates: day, root and section. At each day, 6 roots were measured, with varying numbers of sections for each root. The analysis will need to account for this nested design.

The first step in the analysis is to build a hyperframe as provided in the _spatstat_ package, which consists of all different point patterns and their covariates

```{r}
hypYang = buildHyperFrame(Yang, coordVars = c("x", "y"), imageVars = c("day", "root", "section"))
```

As printed by the code, `r nrow(hypYang)` design factors or point patterns were found. We take a closer look at the hyperframe

```{r}
head(hypYang)
```

We see the following elements:

 - __ppp__: the _spatstat_ point patterns of class _ppp_
 - __design__: The design variable uniquely defining each point pattern. Is a concatenation of the day, root and section variables.
 - __day__, __root__ and __section__: the covariates
 - __tabObs__: tabulation of the frequency of each gene in each point pattern
 
 Zooming in on the first point pattern:
 
```{r}
hypYang$ppp[[1]]
```

As a final confirmation of successfully reading in the data, we can make an exploratory plot:

```{r}
plotExplore(hypYang)
```

# Analyses

## Multithreading

The _spatrans_ package can be computationally intensive, especially for gene pairs. For this reason we provide multithreading through the _BiocParallel_ package. All the user needs to do is prepare the parallel backend as follows:

```{r}
library(BiocParallel)
nCores = 2 #The number of CPUs
register(MulticoreParam(nCores, progressbar = TRUE))
```

The progress bar helps one keep track of the calculations

## Univariate tests

### Tests for univariate aggregation or regularity: interevent distances

The first round of tests concerns the aggregation or regularity of individual genes. We choose to work with nearest neighbour distances here (pi = 'nn'). The background of all other genes serves as null distribution, i.e. we look for genes aggregated _with respect to_ all other genes. As this is computationally most efficient, we also fit the PI for the bivariate analysis in this step ('nnPair', see below).

```{r}
nnObj = estPims(hypYang, pis = c("nn", "nnPair"), null = "background")
```

A data-driven weighing function is now fitted to the estimates of all genes to share information on variances across features. This requires information on the design too: all variables that will be included in the final modelling should be provided to 'designVars'. This includes the lowest level of the design variable, 'section' in this case. The variance is estimated over the different sections of the same day and root.

```{r}
nnObj = addWeightFunction(nnObj, designVars = c("day", "root"))
```

The fitted trend can be plotted:

```{r}
plotWf(nnObj, pi = "nn")
```

As expected the weight increases with the number of observations; quickly at first but latter plateauing. Using this relation between number of observations and variance, a linear mixed model can be fitted per feature. A built-in function prepares the dataframe for a specified gene (here _SmAHK4e_):

```{r}
dfUniNN = buildDfMM(nnObj, gene = "SmAHK4e", pi  = "nn")
```

This dataframe can then be used for mixed modelling, either in R or in an other software package. We present an example analysis below using the _lmerTest_ package, which enhances the _lmer_ package by providing p-values. We fit the following linear mixed model (LMM). The day variable enters the model as a fixed effect, the root as a random effect. We use sum coding for the day variable, meaning that two dummies are created, one for "day0" and one for "day3", so without a reference level. Instead the corresponding parameters are constrained to sum to zero, i.e. to be each other's opposite in this case. This maintains the interpretability of the intercept as the baseline pi, from which the different days can depart, and allows meaningful inference on the intercept.

```{r}
library(lmerTest)
lmeMod = lmerTest::lmer(pi - 0.5 ~ day + (1|root), data = dfUniNN, na.action = na.omit, 
                                 weights = weight, contrasts = list("day" = "contr.sum"))
```

Alternatively, a wrapper function is available that fits such LMMs for every gene:

```{r, include = FALSE}
allModsNN = fitLMMs(nnObj, fixedVars = "day", randomVars = "root")
```

Various errors may occur while fitting, e.g. insufficient non-missing observations. The function finishes silently but returns the error messages in the output. The results can now be viewed as follows

```{r}
head(getResults(allModsNN, "Intercept"))
head(getResults(allModsNN, "day"))
```

## Bivariate tests

### Tests for colocalization or antilocalization: interfeature distances

Tests for colocalization are done by adding the suffix 'Pair' to the PI. All combinations of features provided are fitted. 
Again we plot the weighting function, which is now a bivariate spline as a function of the minority and majority gene:

```{r}
plotWf(nnObj, pi = "nnPair")
```

The least expressed gene or minority gene has the strongest influence on the weight. The dataframe is built in a similar way as before:

```{r}
dfBiNN = buildDfMM(nnObj, gene = "SmVND2--SmPINR", pi  = "nnPair")
```

Finally for the mixed model:

```{r}
lmeModNN = lmerTest::lmer(pi - 0.5 ~ day + (1|root), data = dfBiNN, na.action = na.omit, 
                                 weights = weight, contrasts = list("day" = "contr.sum"))
summary(lmeModNN)
```

We find a significant positive intercept `r summary(lmeModNN)$coef["(Intercept)", "Estimate"]+0.5`, indicating strong antilocalization.

# Eng2019: Mouse brain cells

### Tests for vicinity to cell wall or fixed point: distances to fixed objects
 
# Session info

```{r}
sessionInfo()
```


